
flag = 1325070956009103489249194637347510588506729608784127511926628895543304940415297099207601498626181915901848862854995077315475674257593360012633818395699000501896896712855638114932274873636706679536094148084825113213348693669110684534612150434985589138003619494080556587882502882245480530148296233019306164832959924719530089539412878605051284492900919153291539285764067215954480046474237129247005910958854570936626494664674014970792183182621261776942952172643573955950074108555363333808330455648256916095619261620286120748266415219259665310637340092503523139379869446053982200858497231506892485419429178671743186148288407233657
N = 34825223743402829383680359547814183240817664070909938698674658390374124787235739502688056639022131897715513587903467527066065545399622834534513631867145432553730850980331789931667370903396032758515681278057031496814054828419443822343986117760958186984521716807347123949922837482460532728350223473430713058522361175980521908817215812291272284241848086260180382693014713901303747444753828636575351349026883294939561001468099252543181336195746032718177937417431101756313823635150129601855358558635996348271242920308406268552606733676301725088348399264293936151662467456410825402303921583389167882090767423931762347825907802328053

n = N
e = 65537
ct = flag

# hidden means the lower order bits that are
# changed since there is a randint of 500 bits,
# so the hidden or changed bits are 500.
hidden = 500

#import gmpy2
#r_approx = gmpy2.iroot(N / 0xDEAD / 0xBEEF, 2)
r_approx = isqrt((N)/(0xdead * 0xbeef))
#r_approx1 = 111796788103998177658321958969849839453199412059856792478366698036563669896747646087667801401746562374350529466868051295368899974198676952595653036276254891356381938864492018547180013733414816083348588857577017365433948868295826488678495355740132444820102711896482279073730956297318561403544530501914558032758
#assert r_approx == r_approx1 # working

# do for p
p_approx = 0xDEAD*r_approx + 2**500 # working
#p_approx = 0xDEAD*r_approx - 2**500 # not working
#p_approx = 0xDEAD*r_approx # working

# do for q
#p_approx = 0xBEEF*r_approx - 2**500 # working
#p_approx = 0xBEEF*r_approx + 2**500 # not working
#p_approx = 0xBEEF*r_approx # working

F.<x> = PolynomialRing(Zmod(N), implementation='NTL')
f = x - p_approx

d = f.small_roots(X=2**hidden, beta=0.5)
print('delta',d)
if d:
    d = d[0]
    print('delta',d)
    p = p_approx - d
    print('p = p_approx - delta', p_approx - d)
    q = int(N)//int(p)
    assert (p*q) == N
    phi = (p-1)*(q-1)
    d = inverse_mod(int(e), int(phi))
    print(hex(long(pow(ct,d,n)))[2:-1].decode("hex"))